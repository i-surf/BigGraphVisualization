@()

@defining(play.core.PlayVersion.current) { version =>

    <html>

        <title>Reply Tweets Deck.GL</title>
        <meta name='viewport' />

        <style type="text/css">
                body {
                    margin: 0;
                }
                #container {
                    width: 100%;
                    height: 100%;
                }
                #search{
                    left:500px;
                    top:0px;
                    position:absolute;
                }
        </style>

        <body>

            <div id="graph-container" style="width: 1000px; height: 800px;">
            </div>

            <div id="map" style="width:100vw; height: 100vh"></div>
            <div id = "search">
                <p id="content">Reply Tweets Dataset</p>

                <<!-- input box -> query -->
                <input type="text" class="div" id="query"
                placeholder="Search number of nodes, range from 1-10000, e.g.500. The default value is 5.">
                <button onclick="requestHttp()">submit</button>
            </div>
        </body>

        <script src="/assets/javascripts/sigma.min.js"></script>

        <script src="/assets/javascripts/deckgl.min.js"></script>
        <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v0.50.0/mapbox-gl.js'></script>
        <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v0.50.0/mapbox-gl.css' rel='stylesheet' />

        <script>
                title_list  =[]
                to_list=[]

                global_nodes_title = [] // store ids(titles) of added nodes
                //var global_edges = []

                function requestHttp() {
                    query = document.getElementById("query").value;
                    console.log("query = " + query);

                    var request = new XMLHttpRequest();
                    request.open('GET', 'http://localhost:9000/test2?query=' + query, false);
                    request.send(null);

                    if (request.status === 200) {
                        var data = JSON.parse(request.responseText); // a result of request
                        var title_list_ = data.title_list;
                        var title_list_len = title_list_.length;

                        title_list_ = title_list_.substring(1, title_list_len - 1);
                        title_list = title_list_.split(',');

                        //to_list
                        var to_list_ = data.to_list; // [ㅁ,ㅁ],,[ㅁ],,[ㅁ,ㅁ,ㅁ],,
                        var list_list = to_list_.split(",,"); // a list which contains lists

                        // list_list to a real double_list
                        for (var i = 0; i < list_list.length; i++) {
                            var list = list_list[i];
                            list = list.substring(1, list.length - 1);
                            tmp_list = list.split(','); //string to list
                            to_list.push(tmp_list);
                        }

                        drawGraph();
                    } else {
                        console.log("response error");
                    }
                }

                function drawGraph(){
                    //var s = new sigma('container'); //그래프 그리기 시작
                    var g = {
                        nodes: [],
                        edges: []
                    };

                    var title_list_cnt = title_list.length;
                    global_edges = 0

                    //push a node to a graph object
                    for (var idx=0; idx<title_list_cnt; idx++) {
                        g.nodes.push({
                            //s.graph.addNode({
                            id: title_list[idx],
                            label: title_list[idx],
                            x: Math.random(),
                            y: Math.random(),
                            size: 1,
                            color: '#f00'
                        });

                        global_nodes_title.push(title_list[idx]);
                    }

                    // connect edges
                    for (var i=0; i<title_list_cnt; i++){
                        for (var j=0; j<to_list[i].length; j++){
                            if(global_nodes_title.includes(to_list[i][j])===false){
                                // first, make a node
                                g.nodes.push({
                                    //s.graph.addNode({
                                    id: to_list[i][j],
                                    label: to_list[i][j],
                                    x: Math.random(),
                                    y: Math.random(),
                                    size: 1,
                                    color: '#f00'
                                });

                                // mark that node is made
                                global_nodes_title.push(to_list[i][j]);

                                //connect edges
                                g.edges.push({
                                    id : global_edges,
                                    source: title_list[i],
                                    target: to_list[i][j],
                                    size: 3,
                                    color: '#00f',
                                    type:'arrow'
                                });
                            }

                            // if it is an exist node
                            else{
                                g.edges.push({
                                    id : global_edges,
                                    source: title_list[i],
                                    target: to_list[i][j],
                                    size: 3,
                                    color: '#00f',
                                    type:'arrow'
                                });
                            }

                            global_edges += 1;
                        }
                    }

                    var s = new sigma({
                        graph: g,
                        container: 'graph-container',
                        renderer: {
                            container: document.getElementById('graph-container'),
                            type: 'WebGL',
                        },
                        settings: { // change the size of the node depending on the number of data
                            minNodeSize: 8, // node label is shown if it is bigger than 7
                            maxNodeSize: 8, // node label is shown if it is bigger than 7
                            maxEdgeSize: 1, // 3 or 4
                            doubleClickEnabled: false,
                            arrowSizeRatio: 2.2,
                            /*
                               each graph is formed based on center of circle
                               It seems to mean the degree of spreadability
                               If I set as 30, it goes out of the screen.
                               1 maybe vary.
                            */
                        }
                    });
                    s.refresh();
                }
        </script>
    </html>
}}}


